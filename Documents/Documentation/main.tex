\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{adjustbox}

\title{Drone Controller Documentation}
\author{Tim Arendes}
\date{July 2021}

\begin{document}

\maketitle


\section{Example input}
This is just a placeholder for an actual input later on. All coordinates are in AirSim format, meaning that one can just compy the coordinates needed directly out of AirSim. For everything, we have x,y and z coordinates, with z representing height, similar to AirSim. We have:\\

\begin{description}
    \item[discretization\_factor:] Discretisation from AirSim to PRISM. If 100, then a width of 1000 in AirSim becomes a width of 10 in PRISM.
    \item[*\_0:] AirSim location, where our box begins.
    \item[start\_*:] AirSim location, where the drone starts.
    \item[*\_max:] AirSim location, where the box stops. Together with *\_0, this completely defines our box of operation.
    \item[goal\_*:] AirSim location of the goal.
\end{description}

\section{Grid graph}
To store the information about the current environment. Saves information about the box of operation and start/goal position. This is saved as AirSim coordinates, as well as PRISM coordinates, so that, whatever is needed, both can be used.
Also saves a map that saves all objects in the box of operation. Each objects gets a unique id. We have:\\

\begin{description}
    \item[objects:] Dictionary from id(int) to object. Used to save all objects
    \item[alpha:] To save the factor between AirSim coordinates and PRISM. Basically the same as discretisation in the example input
    \item[AirSim\_*\_0:] AirSim location, where our box begins.
    \item[AirSim\_start\_*:] AirSim location, where the drone starts.
    \item[AirSim\_max\_*:] AirSim location, where the box stops. Together with *\_0, this completely defines our box of operation.
    \item[AirSim\_goal\_*:] AirSim location of the goal.
    \item[PRISM\_start\_x:] Starting position for the PRISM model.
    \item[PRISM\_width/depth/height:] Number of points in all directions in the PRISM model.
    \item[PRISM\_goal\_*:] Goal position in the PRISM model.
    \item[next\_obj\_id:] The id given to the next added object. Increases after adding one object.
\end{description}

\subsection{add\_object}
Adds another object to the grid graph. Returns id of added object.

\begin{description}
    \item[min\_*:] Minimal value for a specific direction. Input given as AirSim coordinate.
    \item[max\_*:] Maximal value for a specific direction. Input given as AirSim coordinate.
\end{description}

\subsection{get\_object\_count}
returns the number of objects in the grid graph.

\section{object}
Saves information about an object. Is not directly generated by user, but by add\_object method.

\begin{description}
    \item[min\_*:] Minimal value for a specific direction. Input given as AirSim coordinate.
    \item[max\_*:] Maximal value for a specific direction. Input given as AirSim coordinate.
    \item[id:] unique identifier with which object is stored in the grid graph
\end{description}
    

\section{Graph\_initializer}
Used to initialize the Grid graph. Currently takes operating space information from hard coded Example input, later on could read a file/ ask server. Can either call AirSim to find the objects, or read a file for them.

\begin{description}
    \item[use\_file:] Boolean, to indicate, if the objects should be read from file. If not, then AirSim gets called.
\end{description}

\subsection{create\_blocks\_graph}
Creates small part of blocks environment as a Grid graph. Either load objects from a file, or calls AirSim to find them. Returns the grid graph with objects.

\subsection{read\_object\_file}
Reads the objects from a file. Each line contains one object, with the coordinates in order of: "x\_min, y\_min, z\_min, x\_max, y\_max, z\_max", separated with ", ".

\subsection{write\_object\_file}
Saves the objects in the file "objects.txt". Saves each object by itself. Each line contains one object, with the coordinates in order of: "x\_min, y\_min, z\_min, x\_max, y\_max, z\_max", separated with ", ".


\section{helper\_functions}
Smaller helper functions, that get used by other functions.

\subsection{PRISM\_to\_AirSim\_API}
Converts the given input of PRISM coordinates as coordinates that the AirSim API wants. Returns a list with position 0 being x, position 1 being y and position 2 being z.

\begin{description}
    \item[PRISM\_*:] Coordinate inside PRISM
    \item[GridGraph:] The GridGraph from which the coordinates are computed from. Needed for alpha, startpositions etc.
\end{description}

\subsection{get\_path}
Takes the output of calling PRISM and computes the coordinates of the path PRISM finds to the goal. Assumes, that such a path exists, and the goal is not unreachable. Returns a list of coordinates, where the coordinates are Lists of the form [x\_position, y\_position, z\_position]. All coordinates are PRISM coordinates.

\begin{description}
    \item[result:] String returned from running PRISM on some model.
\end{description}

\subsection{model\_possible}
checks, if the model that was checked was possible. Uses the output of prism and checks for a sign, that the goal can't be reached(False), otherwise, it finds that the goal can be reached(True).

\begin{description}
    \item[output:] String returned from running PRISM on some model.
\end{description}

\subsection{model\_creator}
Contains the functions that create the models that are needed. Saves them in /Files directory. 

\subsection{create\_pm}
Creates the basic model that tries to go from the start defined in the GridGraph to the end. Model is named "model.pm"

\begin{description}
    \item[GridGraph:] The graph describing the environment.
\end{description}

\subsection{create\_check\_pm}
Creates a model, that can be used to check, if the given path is still possible. Drone is limited to the path and starts at the beginning of it (first coordinate). Model is named "check\_model.pm"

\begin{description}
    \item[path:] The path the drone is supposed to fly in PRISM coordinates.
    \item[GridGraph:] The graph describing the environment.
\end{description}

\subsection{create\_new\_path\_pm}
Creates a model to find a new path to the goal. Drone is not limited to the path, but begins at the start of the path(first coordinate). Model is named "model.pm"

\begin{description}
    \item[path:] The path which is used for the starting position(first coordinate)
    \item[GridGraph:] The graph describing the environment.
\end{description}

\section{object}
Class to describe one object in the Grid graph. Coordinates are given in PRISM values.

\begin{description}
    \item[id:] Unique id of an object.
    \item[*\_min:] minimal value in one direction in PRISM coordinates.
    \item[*\_max:] maximal value in one direction in PRISM coordinates.
\end{description}

\section{PRISM\_calls}
Contains command to call PRISM. Currently only one command.

\subsection{execute\_PRISM\_model}
Executes PRISM on some model. The name of the model is given as argument. Returns the output of PRISM. Expects the model and properties to be in the Files directory.

\begin{description}
    \item[model\_name:] Name of the model that is supposed to be executed.
\end{description}

\section{main}
Contains the main threads that are used to coordinate everything and the main that controls these threads. Contains mutexes for variables that get used by multiple threads. To avoid deadlocks, always lock in the same order as the mutexes are given (in the file or in this documentation, same order)

\begin{description}
    \item[mtx\_path:] Mutex for the path the drone is supposed to fly.
    \item[mtx\_step:] Mutex for the step the drone is at in the path.
    \item[mtx\_possible:] Mutex for the boolean that states, if it is possible for the drone to fly to the goal with the current path.
    \item[mtx\_graph:] Mutex for the Grid graph describing the environment.
    \item[mtx\_changes:] Mutex for the boolean that states, if changes were made to the Grid graph.
\end{description}

\subsection{path\_checker}
Until the drone is at the goal, checks if changes were made to the path. If changes were made, check if the current path is still possible. If it is not, try to find a new path. If no new path can be found, try this again until one can be found. Needs: mtx\_path, mtx\_step, mtx\_possible, mtx\_graph, mtx\_changes

\begin{description}
    \item[path:] The path the drone is supposed to fly. Gets changed, if new path needs to be calculated
    \item[step:] The current step the drone is at on the current path.
    \item[possible:] Boolean stating, if it is possible for the drone to fly along the current path.
    \item[graph:] The Grid graph describing the environment.
    \item[changes:] Boolean stating, if changes were made to the Grid graph.
\end{description}

\subsection{graph\_updater}
Used to update the graph. Later on will be connected to AirSim in some way to update accordingly, at the moment can either place a block that blocks the path(block = True), so that the drone needs to fly above the obstacle, or place one were the drone was, which does not change the behaviour of the drone. Needs: mtx\_graph, mtx\_changes.

\begin{description}
    \item[graph:] The Grid graph describing the environment.
    \item[changes:] Boolean stating, if changes were made to the Grid graph.
\end{description}

\subsection{AirSim\_control}
Used to send commands via the AirSim API to make the drone fly along the path. Runs, until the drone is at the goal. Send one coordinate after anothe with "client.moveToPositionAsync" with velocity 5. If Drone is blocked, waits until a new path is found. Needs: mtx\_path, mtx\_step, mtx\_possible, mtx\_graph

\begin{description}
    \item[path:] The path the drone is supposed to fly.
    \item[step:] The current step the drone is at on the current path. Gets changed here.
    \item[possible:] Boolean stating, if it is possible for the drone to fly along the current path.
    \item[graph:] The Grid graph describing the environment.
\end{description}

\subsection{main}
Main function controlling the three threads. Creates the first model and its path, initialized the shared variables and then starts the threads. Shared Booleans and Integer are saved as List, so that we can change the value and keep the reference in the single threads(use step[0] instead of step for example).

\section{object\_finder}
Contains functions, that are used for the automatic detection of objects in the given task.

\begin{description}
    \item[merging\_distance:] The maximum distance at which two objects get merged, given in AirSim coordinate length.
    \item[box\_safety\_scaling:] A scaling factor which makes the boxes of objects a bit bigger than the objects themselves, to make the Flight more save. Multiplies with the width etc.. Could be changed to a constant safety margin instead of a multiplicative.
\end{description}

\subsection{get\_objects}
Calls AirSim to get every AirSim\_object, and creates the objects accordingly. Only creates objects for known AirSim\_objects, by comparing their names.

\begin{description}
    \item[graph:] The grid graph, not containing any objects at this time.
\end{description}

\subsection{inbounds}
Detects, if the given objects is inside the area in which the drone is flying. Used to not include objects, that are outside of this area, as they are not important.

\begin{description}
    \item[graph:] The grid graph, not containing any objects at this time.
    \item[obj:] The objects, which gets checked, if it is inside the bounds.
\end{description}

\subsection{merge\_objects}
Merges the two given objects into one single one. Takes the maximum/minimum of both objects, so that every part of the old objects is part of the new objects.

\begin{description}
    \item[obj\_*:] The objects, which should be merged.
\end{description}


\subsection{check\_merging}
Checks, if the two given objects should be merged. Currently compares the distance of their middle points, but can change other metrics.

\begin{description}
    \item[obj\_*:] The objects, which maybe should be merged.
\end{description}

\subsection{create\_TemplateCube\_Rounded\_object}
Takes an AirSim\_objects name, and uses it to find its position and scale, and returns the objects that correspond to these parameters. Currently works for "TemplateCube\_Rounded", other AirSim\_object types can be added in a similar way.

\begin{description}
    \item[client\_*:] The AirSim client, used to make the necessary calls.
    \item[graph\_*:] The graph, with no objects at the moment.
    \item[name\_*:] The name of the AirSim\_object, for which the objects should be computed.
\end{description}


\section{Example PRISM model basic}


mdp\\
\\
formula goal = (x\_pos = 70 \& y\_pos = 42 \& z\_pos = 2);\\
\\
const int max\_x = 76;\\
const int max\_y = 53;\\
const int max\_z = 29;\\
\\
module position\\
\\
    step:[1..2] init 1;\\
\\
    x\_pos:[0..76] init 40;\\
    y\_pos:[0..53] init 51;\\
    z\_pos:[0..29] init 2;\\
\\    
    $[change\_pos] (step = 1) \& (x\_pos + 1 < max\_x)\\
    -> (x\_pos' = x\_pos + 1) \& (step' = 2);$\\
    $[change\_pos] (step = 1) \& (y\_pos + 1 < max\_y)\\
    ->(y\_pos' = y\_pos + 1) \& (step' = 2);$\\
    $[change\_pos] (step = 1) \& (z\_pos + 1 < max\_z)\\
    ->(z\_pos' = z\_pos + 1) \& (step' = 2);$\\
\\   
    $[change\_pos] (step = 1) \& (x\_pos - 1 >= 0) -> (x\_pos' = x\_pos - 1) \& (step' = 2);$\\
    $[change\_pos] (step = 1) \& (y\_pos - 1 >= 0) -> (y\_pos' = y\_pos - 1) \& (step' = 2);$\\
    $[change\_pos] (step = 1) \& (z\_pos - 1 >= 0) -> (z\_pos' = z\_pos - 1) \& (step' = 2);$\\
\\   
    $[check] (step = 2) -> (step' = 1);$\\
\\
endmodule\\
\\
\\    
\\   
const int obj\_0\_min\_x = 24;\\
const int obj\_0\_min\_y = 5;\\
const int obj\_0\_min\_z = -1;\\
const int obj\_0\_max\_x = 38;\\
const int obj\_0\_max\_y = 30;\\
const int obj\_0\_max\_z = 11;\\
\\
module obj\_0\\
$[check] !((x\_pos >= obj\_0\_min\_x) \& (y\_pos >= obj\_0\_min\_y) \& (z\_pos >= obj\_0\_min\_z) \& (x\_pos <= obj\_0\_max\_x) \& (y\_pos <= obj\_0\_max\_y) \& (z\_pos <= obj\_0\_max\_z)) -> true;$\\
endmodule\\
\\
\\   
const int obj\_0\_min\_x = 24;\\
const int obj\_0\_min\_y = 5;\\
const int obj\_0\_min\_z = -1;\\
const int obj\_0\_max\_x = 38;\\
const int obj\_0\_max\_y = 50;\\
const int obj\_0\_max\_z = 11;\\
\\
module obj\_0\\
$[check] !((x\_pos >= obj\_0\_min\_x) \& (y\_pos >= obj\_0\_min\_y) \& (z\_pos >= obj\_0\_min\_z) \& (x\_pos <= obj\_0\_max\_x) \& (y\_pos <= obj\_0\_max\_y)\ \& (z\_pos <= obj\_0\_max\_z)) -> true;$\\
endmodule\\
\\
More objects could can be added in the same way.\\

\section{Further additions}
More things can be added to the PRISM model. Nothing currently in code, but examples can be seen in Documents/Example\_models. In the following, the additions get explained.

\subsection{battery}
Adds a module, that subtracts one from a battery level for every move. One it reaches zero, position can't be changed, so that a deadlock is reached.

\subsection{noop areas}
Adds an additional noop action and a noop area. In this area, one has to make multiple noop actions until the next position change. Allows to make areas less desirable to cross. Subtract one battery state for each noop action. More noop areas can be added, noops in the module have to be given an index then.

\subsection{other drone(simple)}
Adds another drone, that flies along a given path. Only saves the current step of the drone. Checks, if extra drone and main drone collide.

\subsection{other drone(too complex)}
Similar to the previous part, adds another drone, that the main drone has to avoid. This time, also saves the position of the drone in the module. Could handle more things (i.e. probabilistic positions), but is too complex, so it can't be calculated in PRISM.




\end{document}
